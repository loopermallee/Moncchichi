package com.loopermallee.moncchichi.bluetooth

import kotlin.text.Charsets

/**
 * Utilities for parsing raw UART notification frames emitted by the G1 firmware.
 */
object G1MessageParser {

    /**
     * Structured telemetry payload emitted by individual opcodes.
     */
    data class TelemetryUpdate(
        val batteryPercent: Int? = null,
        val firmwareVersion: String? = null,
        val rssi: Int? = null,
        val caseOpen: Boolean? = null,
        val inCase: Boolean? = null,
        val foldState: Boolean? = null,
        val charging: Boolean? = null,
        val lastVitalsTimestamp: Long? = null,
    ) {
        internal fun hasAnyValues(): Boolean {
            return batteryPercent != null ||
                firmwareVersion != null ||
                rssi != null ||
                caseOpen != null ||
                inCase != null ||
                foldState != null ||
                charging != null ||
                lastVitalsTimestamp != null
        }
    }

    /**
     * Represents a textual system frame emitted in response to [G1Protocols.CMD_SYS_INFO].
     */
    data class AsciiSystemFrame(
        val opcode: Int,
        val subOpcode: Int,
        val text: String,
    )

    fun isAsciiOk(payload: ByteArray): Boolean {
        return payload.normalizedAsciiTokens().any { token -> token.equals("OK", ignoreCase = true) }
    }

    fun isAsciiBusy(payload: ByteArray): Boolean {
        return payload.normalizedAsciiTokens().any { token -> token.equals("BUSY", ignoreCase = true) }
    }

    fun isAsciiError(payload: ByteArray): Boolean {
        return payload.normalizedAsciiTokens().any { token -> token.equals("ERROR", ignoreCase = true) }
    }
}

/**
 * Attempts to decode the receiver as an ASCII system frame generated by `0x23 0x74`.
 */
fun ByteArray.toAsciiSystemFrameOrNull(): G1MessageParser.AsciiSystemFrame? {
    if (isEmpty()) return null
    val ascii = runCatching { String(this, Charsets.UTF_8) }.getOrNull() ?: return null
    if (!ascii.all { it == '\r' || it == '\n' || it.code in 0x20..0x7E }) {
        return null
    }
    val trimmed = ascii.trimEnd('\u0000')
    if (trimmed.isBlank()) {
        return null
    }
    return G1MessageParser.AsciiSystemFrame(
        opcode = G1Protocols.CMD_SYS_INFO,
        subOpcode = G1Protocols.SYS_SUB_INFO,
        text = trimmed,
    )
}

internal fun ByteArray.toAckFromAsciiOrNull(): AckOutcome? {
    return when {
        G1MessageParser.isAsciiOk(this) -> AckOutcome.Success(
            opcode = G1Protocols.CMD_SYS_INFO,
            status = G1Protocols.STATUS_OK,
        )
        G1MessageParser.isAsciiBusy(this) -> AckOutcome.Busy(
            opcode = G1Protocols.CMD_SYS_INFO,
            status = G1Protocols.STATUS_BUSY,
        )
        G1MessageParser.isAsciiError(this) -> AckOutcome.Failure(
            opcode = G1Protocols.CMD_SYS_INFO,
            status = null,
        )
        else -> null
    }
}

fun ByteArray.toTelemetryUpdateOrNull(): G1MessageParser.TelemetryUpdate? {
    if (isEmpty()) return null
    val opcode = this[0].toInt() and 0xFF
    val update = when (opcode) {
        0x0E -> G1MessageParser.TelemetryUpdate(caseOpen = booleanAt(1))
        0x0F -> G1MessageParser.TelemetryUpdate(inCase = booleanAt(1))
        0x18, G1Protocols.CMD_WEAR_DETECT -> G1MessageParser.TelemetryUpdate(foldState = booleanAt(1))
        else -> null
    } ?: return null
    return update.takeIf { it.hasAnyValues() }
}

private fun ByteArray.normalizedAsciiTokens(): List<String> {
    if (isEmpty()) return emptyList()
    val ascii = runCatching { String(this, Charsets.UTF_8) }.getOrNull() ?: return emptyList()
    return ascii
        .split('\r', '\n')
        .asSequence()
        .map { candidate ->
            candidate
                .replace("\u0000", "")
                .trim { it <= ' ' }
                .trimStart { it == '>' }
                .trim { it <= ' ' }
        }
        .filter { it.isNotEmpty() }
        .toList()
}

private fun ByteArray.booleanAt(index: Int): Boolean? {
    val raw = getOrNull(index)?.toInt()?.and(0xFF) ?: return null
    return when (raw) {
        0 -> false
        1 -> true
        else -> null
    }
}
