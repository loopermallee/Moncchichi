package com.loopermallee.moncchichi.bluetooth

import kotlin.text.Charsets

/**
 * Utilities for parsing raw UART notification frames emitted by the G1 firmware.
 */
object G1MessageParser {

    /**
     * Represents a textual system frame emitted in response to [G1Protocols.CMD_SYS_INFO].
     */
    data class AsciiSystemFrame(
        val opcode: Int,
        val subOpcode: Int,
        val text: String,
    )

    fun isAsciiOk(payload: ByteArray): Boolean {
        return payload.normalizedAsciiTokens().any { token -> token.equals("OK", ignoreCase = true) }
    }

    fun isAsciiBusy(payload: ByteArray): Boolean {
        return payload.normalizedAsciiTokens().any { token -> token.equals("BUSY", ignoreCase = true) }
    }

    fun isAsciiError(payload: ByteArray): Boolean {
        return payload.normalizedAsciiTokens().any { token -> token.equals("ERROR", ignoreCase = true) }
    }
}

/**
 * Attempts to decode the receiver as an ASCII system frame generated by `0x23 0x74`.
 */
fun ByteArray.toAsciiSystemFrameOrNull(): G1MessageParser.AsciiSystemFrame? {
    if (isEmpty()) return null
    val ascii = runCatching { String(this, Charsets.UTF_8) }.getOrNull() ?: return null
    if (!ascii.all { it == '\r' || it == '\n' || it.code in 0x20..0x7E }) {
        return null
    }
    val trimmed = ascii.trimEnd('\u0000')
    if (trimmed.isBlank()) {
        return null
    }
    return G1MessageParser.AsciiSystemFrame(
        opcode = G1Protocols.CMD_SYS_INFO,
        subOpcode = G1Protocols.SYS_SUB_INFO,
        text = trimmed,
    )
}

internal fun ByteArray.toAckFromAsciiOrNull(): AckOutcome? {
    return when {
        G1MessageParser.isAsciiOk(this) -> AckOutcome.Success(
            opcode = G1Protocols.CMD_SYS_INFO,
            status = G1Protocols.STATUS_OK,
        )
        G1MessageParser.isAsciiBusy(this) -> AckOutcome.Busy(
            opcode = G1Protocols.CMD_SYS_INFO,
            status = G1Protocols.STATUS_BUSY,
        )
        G1MessageParser.isAsciiError(this) -> AckOutcome.Failure(
            opcode = G1Protocols.CMD_SYS_INFO,
            status = null,
        )
        else -> null
    }
}

private fun ByteArray.normalizedAsciiTokens(): List<String> {
    if (isEmpty()) return emptyList()
    val ascii = runCatching { String(this, Charsets.UTF_8) }.getOrNull() ?: return emptyList()
    return ascii
        .split('\r', '\n')
        .asSequence()
        .map { candidate ->
            candidate
                .replace("\u0000", "")
                .trim { it <= ' ' }
                .trimStart { it == '>' }
                .trim { it <= ' ' }
        }
        .filter { it.isNotEmpty() }
        .toList()
}
